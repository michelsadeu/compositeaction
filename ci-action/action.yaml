name: 'Parse /ci Comment'
description: 'Parse and extract parameters from /ci comments'
author: 'Michel-SG'

inputs:
  github-token:
    description: 'GitHub token for API access'
    required: false
    default: ${{ github.token }}

outputs:
  target:
    description: 'Target parameter'
    value: ${{ steps.parse-ci.outputs.TARGET }}
  version:
    description: 'Version parameter'
    value: ${{ steps.parse-ci.outputs.VERSION }}
  coverage:
    description: 'Coverage parameter'
    value: ${{ steps.parse-ci.outputs.COVERAGE }}
  parameters:
    description: 'All parameters as JSON'
    value: ${{ steps.parse-ci.outputs.parameters }}
  workflow_call_triggered:
    description: 'Whether run_ci workflow was triggered successfully'
    value: ${{ steps.trigger-workflow-call.outputs.workflow_call_triggered }}
  workflow_dispatch_triggered:
    description: 'Whether run_ci workflow (second) was triggered successfully'
    value: ${{ steps.trigger-workflow-dispatch.outputs.workflow_dispatch_triggered }}
  trigger_action_result:
    description: 'Whether trigger-action was executed successfully'
    value: ${{ steps.trigger-action.outputs.workflow_triggered }}
  trigger_action_call_result:
    description: 'Whether trigger-action-call was executed successfully'
    value: ${{ steps.trigger-action-call.outputs.workflow_triggered }}

runs:
  using: "composite"
  steps:
    - name: Parse /ci comment
      id: parse-ci
      uses: actions/github-script@v7
      with:
        github-token: ${{ inputs.github-token }}
        script: |
          try {
            const commentBody = context.payload.comment?.body || '';
            
            core.info(`üìù Commentaire re√ßu: ${commentBody}`);
            
            // V√©rifier si le commentaire commence par /ci
            if (!commentBody.startsWith('/ci')) {
              throw new Error('Le commentaire ne commence pas par /ci');
            }
            
            core.info('‚úÖ Commande /ci d√©tect√©e');
            
            // Extraire la partie apr√®s "/ci "
            const paramsString = commentBody.substring(4).trim();
            
            if (!paramsString) {
              throw new Error('Aucun param√®tre trouv√© apr√®s /ci');
            }
            
            core.info(`üì¶ Param√®tres bruts: ${paramsString}`);
            
            // Parser les param√®tres
            const paramArray = paramsString
              .split(';')
              .map(p => p.trim())
              .filter(p => p);
            
            const params = {};
            let paramCount = 0;
            
            for (const param of paramArray) {
              const colonIndex = param.indexOf(':');
              
              if (colonIndex === -1) {
                core.warning(`‚ö†Ô∏è Format invalide pour le param√®tre: ${param}`);
                continue;
              }
              
              const cleanKey = param.substring(0, colonIndex).trim().toLowerCase();
              const cleanValue = param.substring(colonIndex + 1).trim();
              
              if (!cleanKey || !cleanValue) {
                core.warning(`‚ö†Ô∏è Param√®tre incomplet: cl√©="${cleanKey}", valeur="${cleanValue}"`);
                continue;
              }
              
              core.info(`‚úì Param√®tre trouv√©: ${cleanKey} = ${cleanValue}`);
              
              params[cleanKey] = cleanValue;
              core.setOutput(cleanKey.toUpperCase(), cleanValue);
              paramCount++;
            }
            
            if (paramCount === 0) {
              throw new Error('Aucun param√®tre valide trouv√©');
            }
            
            core.info(`‚úÖ ${paramCount} param√®tre(s) extrait(s) avec succ√®s`);
            core.info(`üìä R√©sum√©: ${JSON.stringify(params)}`);
            
            // Exporter tous les param√®tres en JSON
            core.setOutput('parameters', JSON.stringify(params));
            
          } catch (error) {
            core.setFailed(`‚ùå Erreur: ${error.message}`);
          }
    
    - name: Trigger jenkinstest run_ci workflow
      id: trigger-workflow-call
      uses: actions/github-script@v7
      continue-on-error: true
      with:
        github-token: ${{ inputs.github-token }}
        script: |
          try {
            core.info('üì§ D√©clenchement du workflow run_ci sur michelsadeu/jenkinstest');
            
            const target = '${{ steps.parse-ci.outputs.TARGET }}';
            const version = '${{ steps.parse-ci.outputs.VERSION }}';
            const coverage = '${{ steps.parse-ci.outputs.COVERAGE }}';
            const message = `CI triggered with parameters: target=${target}, version=${version}, coverage=${coverage}`;
            
            core.info(`üìä Message: ${message}`);
            
            // Extraire le PR number depuis le contexte
            const prNumber = context.issue.number;
            core.info(`üî¢ PR Number: ${prNumber}`);
            
            const dispatchResponse = await github.rest.actions.createWorkflowDispatch({
              owner: 'michelsadeu',
              repo: 'jenkinstest',
              workflow_id: 'run_ci.yml',
              ref: 'main',
              inputs: {
                pr_number: String(prNumber),
                message: message
              }
            });
            
            core.info('‚úÖ run_ci workflow d√©clench√© avec succ√®s');
            core.setOutput('workflow_call_triggered', 'true');
            
          } catch (error) {
            core.warning(`‚ö†Ô∏è Erreur run_ci: ${error.message}`);
            core.warning(`Status: ${error.status}`);
            core.setOutput('workflow_call_triggered', 'false');
          }

    - name: Trigger jenkinstest run_ci workflow (second dispatch)
      id: trigger-workflow-dispatch
      uses: actions/github-script@v7
      continue-on-error: true
      with:
        github-token: ${{ inputs.github-token }}
        script: |
          try {
            core.info('üì§ D√©clenchement du workflow run_ci (second) sur michelsadeu/jenkinstest');
            
            const target = '${{ steps.parse-ci.outputs.TARGET }}';
            const version = '${{ steps.parse-ci.outputs.VERSION }}';
            const coverage = '${{ steps.parse-ci.outputs.COVERAGE }}';
            const message = `CI triggered with parameters: target=${target}, version=${version}, coverage=${coverage}`;
            
            core.info(`üìä Message: ${message}`);
            
            // Extraire le PR number depuis le contexte
            const prNumber = context.issue.number;
            core.info(`üî¢ PR Number: ${prNumber}`);
            
            const dispatchResponse = await github.rest.actions.createWorkflowDispatch({
              owner: 'michelsadeu',
              repo: 'jenkinstest',
              workflow_id: 'run_ci.yml',
              ref: 'main',
              inputs: {
                pr_number: String(prNumber),
                message: message
              }
            });
            
            core.info('‚úÖ run_ci workflow (second) d√©clench√© avec succ√®s');
            core.setOutput('workflow_dispatch_triggered', 'true');
            
          } catch (error) {
            core.warning(`‚ö†Ô∏è Erreur run_ci (second): ${error.message}`);
            core.warning(`Status: ${error.status}`);
            core.setOutput('workflow_dispatch_triggered', 'false');
          }

    - name: Trigger workflow with parsed parameters
      id: trigger-action
      uses: michelsadeu/jenkinstest/.github/workflows/run_ci.yml@main
      with:
        pr_number: ${{ github.event.issue.number }}
        message: "CI triggered with parameters: target=${{ steps.parse-ci.outputs.TARGET }}, version=${{ steps.parse-ci.outputs.VERSION }}, coverage=${{ steps.parse-ci.outputs.COVERAGE }}"

    - name: Trigger workflow with parsed parameters (workflow_call)
      id: trigger-action-call
      uses: michelsadeu/jenkinstest/.github/workflows/run_ci.yml@main
      with:
        pr_number: ${{ github.event.issue.number }}
        message: "CI triggered with parameters: target=${{ steps.parse-ci.outputs.TARGET }}, version=${{ steps.parse-ci.outputs.VERSION }}, coverage=${{ steps.parse-ci.outputs.COVERAGE }}"
